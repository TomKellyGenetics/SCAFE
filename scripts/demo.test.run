#!/usr/bin/perl -w

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE


#====================================================================================================================================================#
#<use>
$|++; #---turn on the auto flush for the progress bar
use warnings;
use strict;
use Getopt::Long 'HelpMessage';
use Time::HiRes qw( time );
use File::Spec::Functions qw(rel2abs abs2rel);
use Cwd 'abs_path';
#<\use>
#====================================================================================================================================================#

#====================================================================================================================================================#
#<doc>
=head1 SYNOPSIS

                      O~~~AA      O~~         O~       O~~~~~~~AO~~~~~~~~A
                    O~~    O~~ O~~   O~~     O~ ~~     O~~      O~~       
                     O~~      O~~           O~  O~~    O~~      O~~       
                       O~~    O~~          O~~   O~~   O~~~~~AA O~~~~~~A  
                          O~~ O~~         O~~~~~A O~~  O~~      O~~       
                    O~~    O~~ O~~   O~~ O~~       O~~ O~~      O~~       
                      O~~~~A     O~~~   O~~         O~~O~~      O~~~~~~~AA

                      Single Cell Analysis of Five'End (SCAFE) Tool Suite 
                                  ---> demo.test.run <---
                        <--- demo, run demo data for testing --->

 Description:
   This scripts test run for demo data in the ./demo/input dir. It runs all six workflows.
   Demo input data must be downloaded from using ./script/download.demo.input
   Genome reference hg19.gencode_v32lift37 must be downloaded using ./scripts/download.resources.genome

 Usage:
   demo.test.run [options] --run_outDir
   
   --run_outDir           <required> [string]  directory for the output test runs
   --overwrite            (optional) [yes/no]  erase run_outDir before running (default=no)

 Dependencies:
   R packages: 'ROCR','PRROC', 'caret', 'e1071', 'ggplot2', 'scales', 'reshape2'
   bigWigAverageOverBed
   bedGraphToBigWig
   bedtools
   samtools
   paraclu
   paraclu-cut.sh

 For demo, cd to SCAFE dir and run,
   ./scripts/demo.test.run \
   --overwrite=yes \
   --run_outDir=./demo/output/

=head1 VERSION

1.0

=cut
#<\doc>
#====================================================================================================================================================#

#====================================================================================================================================================#
#<lastCmdCalled>
#
#	notCalledBefore
#
#	notCalledBefore
#
#<\lastCmdCalled>
#====================================================================================================================================================#

#====================================================================================================================================================#
#<global>
#<\global>
#====================================================================================================================================================#

#====================================================================================================================================================#
{	#Main sections lexical scope starts
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 0_startTasks
#
#<section ID="startTasks" num="0">
my $ARGV_ary_ref = [@ARGV];
my ($run_outDir, $overwrite) = &readParameters();#->313
my ($scafe_dir, $script_dir, $result_script_dir, $ARGVStr, $scriptAbsPath) = &prepDir($run_outDir, $ARGV_ary_ref);#->285
&logCalledCMDAndScript($ARGVStr, $result_script_dir, $scriptAbsPath);#->260
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 1_run
#
#<section ID="run" num="1">
my $genome='hg19.gencode_v32lift37';
my $run_tag='demo';
my ($path_hsh_ref) = &define_path($run_outDir, $script_dir, $scafe_dir);#->141
my ($task_info_hsh_ref) = &define_task($genome, $path_hsh_ref, $run_tag, $run_outDir);#->170
&run_task($task_info_hsh_ref, $path_hsh_ref, $result_script_dir);#->346
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
}	#Main sections lexical scope ends
#====================================================================================================================================================#

#====================================================================================================================================================#
#List of subroutines by category
#
#	general [n=3]:
#		currentTime, logCalledCMDAndScript, readParameters
#
#	unassigned [n=4]:
#		define_path, define_task, prepDir
#		run_task
#
#====================================================================================================================================================#

sub currentTime {
#....................................................................................................................................................#
#	subroutineCategory: general
#	dependOnSub: >none
#	appearInSub: prepDir|285
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 0_startTasks|84
#	input: none
#	output: $runTime
#	toCall: my ($runTime) = &currentTime();
#	calledInLine: 299
#....................................................................................................................................................#
	
	my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst)=localtime(time);
	my $runTime = sprintf "%04d-%02d-%02d %02d:%02d", $year+1900, $mon+1,$mday,$hour,$min;	
	
	return $runTime;
}
sub define_path {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 1_run|95
#	secondaryAppearInSection: >none
#	input: $run_outDir, $scafe_dir, $script_dir
#	output: $path_hsh_ref
#	toCall: my ($path_hsh_ref) = &define_path($run_outDir, $script_dir, $scafe_dir);
#	calledInLine: 100
#....................................................................................................................................................#

	my ($run_outDir, $script_dir, $scafe_dir) = @_;
	
	my $path_hsh_ref = {
		'script_dir' => $script_dir,
		'UMI_CB_ctss_bed_path' => $scafe_dir."/demo/input/sc.subsample/demo.UMI_CB.ctss.bed.gz",
		'run_cellbarcode_path' => $scafe_dir."/demo/input/sc.subsample/demo.barcodes.tsv.gz",
		'sc.run_bam_path' => $scafe_dir."/demo/input/sc.solo/demo.cellranger.bam",
		'sc.lib_list_path' => $scafe_dir."/demo/input/sc.pool/lib_list_path.txt",
		'long_ctss_bed_path' => $scafe_dir."/demo/input/bk.subsample/demo.long.ctss.bed.gz",
		'bk.run_bam_path' => $scafe_dir."/demo/input/bk.solo/demo.CAGE.bam",
		'bk.lib_list_path' => $scafe_dir."/demo/input/bk.pool/lib_list_path.txt",
	};

	return ($path_hsh_ref);

}
sub define_task {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 1_run|95
#	secondaryAppearInSection: >none
#	input: $genome, $path_hsh_ref, $run_outDir, $run_tag
#	output: $task_info_hsh_ref
#	toCall: my ($task_info_hsh_ref) = &define_task($genome, $path_hsh_ref, $run_tag, $run_outDir);
#	calledInLine: 101
#....................................................................................................................................................#

	my ($genome, $path_hsh_ref, $run_tag, $run_outDir) = @_;

	my $task_info_hsh_ref = {
		1 => {
			'task_name' => 'bk.pool',
			'script_name' => 'workflow.bk.pool',
			'task_log_path' => $run_outDir."/bk.pool/script/task.log.txt",
			'param' => [
				['overwrite', 'yes'],
				['lib_list_path', $path_hsh_ref->{'bk.lib_list_path'}],
				['genome', $genome],
				['run_tag', $run_tag],
				['run_outDir', $run_outDir."/bk.pool"],
			],
		},
		2 => {
			'task_name' => 'bk.solo',
			'script_name' => 'workflow.bk.solo',
			'task_log_path' => $run_outDir."/bk.solo/script/task.log.txt",
			'param' => [
				['overwrite', 'yes'],
				['run_bam_path', $path_hsh_ref->{'bk.run_bam_path'}],
				['genome', $genome],
				['run_tag', $run_tag],
				['run_outDir', $run_outDir."/bk.solo"],
			],
		},
		3 => {
			'task_name' => 'bk.subsample',
			'script_name' => 'workflow.bk.subsample',
			'task_log_path' => $run_outDir."/bk.subsample/script/task.log.txt",
			'param' => [
				['overwrite', 'yes'],
				['long_ctss_bed_path', $path_hsh_ref->{'long_ctss_bed_path'}],
				['subsample_num', 100000],
				['genome', $genome],
				['run_tag', $run_tag],
				['run_outDir', $run_outDir."/bk.subsample"],
			],
		},
		4 => {
			'task_name' => 'sc.pool',
			'script_name' => 'workflow.sc.pool',
			'task_log_path' => $run_outDir."/sc.pool/script/task.log.txt",
			'param' => [
				['overwrite', 'yes'],
				['lib_list_path', $path_hsh_ref->{'sc.lib_list_path'}],
				['genome', $genome],
				['run_tag', $run_tag],
				['run_outDir', $run_outDir."/sc.pool"],
			],
		},
		5 => {
			'task_name' => 'sc.solo',
			'script_name' => 'workflow.sc.solo',
			'task_log_path' => $run_outDir."/sc.solo/script/task.log.txt",
			'param' => [
				['overwrite', 'yes'],
				['run_bam_path', $path_hsh_ref->{'sc.run_bam_path'}],
				['run_cellbarcode_path', $path_hsh_ref->{'run_cellbarcode_path'}],
				['genome', $genome],
				['run_tag', $run_tag],
				['run_outDir', $run_outDir."/sc.solo"],
			],
		},
		6 => {
			'task_name' => 'sc.subsample',
			'script_name' => 'workflow.sc.subsample',
			'task_log_path' => $run_outDir."/sc.subsample/script/task.log.txt",
			'param' => [
				['overwrite', 'yes'],
				['UMI_CB_ctss_bed_path', $path_hsh_ref->{'UMI_CB_ctss_bed_path'}],
				['run_cellbarcode_path', $path_hsh_ref->{'run_cellbarcode_path'}],
				['subsample_num', 100000],
				['genome', $genome],
				['run_tag', $run_tag],
				['run_outDir', $run_outDir."/sc.subsample"],
			],
		},
	};
	
	return($task_info_hsh_ref);
}
sub logCalledCMDAndScript {
#....................................................................................................................................................#
#	subroutineCategory: general
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 0_startTasks|84
#	secondaryAppearInSection: >none
#	input: $ARGVStr, $result_script_dir, $scriptAbsPath
#	output: 
#	toCall: &logCalledCMDAndScript($ARGVStr, $result_script_dir, $scriptAbsPath);
#	calledInLine: 90
#....................................................................................................................................................#
	my ($ARGVStr, $result_script_dir, $scriptAbsPath) = @_;


	my $cpScriptPath = "$result_script_dir/script.ran.pl";
	my $calledCMDPath = "$result_script_dir/called.cmd.txt";
	system "cp -f $scriptAbsPath $cpScriptPath";
	system "chmod 0444 $cpScriptPath"; #---[07/03/2014 18:02] make it read-only to make sure there'll be accodental change of parameters
	open CALLEDCMD, ">", $calledCMDPath;
	print CALLEDCMD join "", ($ARGVStr), "\n";
	close CALLEDCMD;
	
	return ();
}
sub prepDir {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: currentTime|123
#	appearInSub: >none
#	primaryAppearInSection: 0_startTasks|84
#	secondaryAppearInSection: >none
#	input: $ARGV_ary_ref, $run_outDir
#	output: $ARGVStr, $result_script_dir, $scafe_dir, $scriptAbsPath, $script_dir
#	toCall: my ($scafe_dir, $script_dir, $result_script_dir, $ARGVStr, $scriptAbsPath) = &prepDir($run_outDir, $ARGV_ary_ref);
#	calledInLine: 89
#....................................................................................................................................................#
	my ($run_outDir, $ARGV_ary_ref) = @_;

	my $scriptAbsPath = abs_path($0);
	my $ARGVStr = join "\n", (&currentTime(), $scriptAbsPath, @{$ARGV_ary_ref});#->123
	my @path_split = split /\//, $scriptAbsPath;
	my $scafe_dir_index = $#path_split-2;
	my $script_dir_index = $#path_split-1;
	my $scafe_dir = join "/", @path_split[0..$scafe_dir_index];
	my $script_dir = join "/", @path_split[0..$script_dir_index];

	my @mkDirAry;
	my $result_script_dir = "$run_outDir/script/"; push @mkDirAry, $result_script_dir;
	foreach my $dir (@mkDirAry) {system ("mkdir -pm 755 $dir");}

	return ($scafe_dir, $script_dir, $result_script_dir, $ARGVStr, $scriptAbsPath);
}
sub readParameters {
#....................................................................................................................................................#
#	subroutineCategory: general
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 0_startTasks|84
#	secondaryAppearInSection: >none
#	input: none
#	output: $overwrite, $run_outDir
#	toCall: my ($run_outDir, $overwrite) = &readParameters();
#	calledInLine: 88
#....................................................................................................................................................#
	
	my ($run_outDir, $overwrite);
	
	$overwrite = 'no';

	GetOptions 	(
		"overwrite:s"		=>	\$overwrite,
		"run_outDir=s"		=>	\$run_outDir,
		'help'				=>	sub { HelpMessage(0) },
	) or HelpMessage(1);

	HelpMessage(1) unless $run_outDir;

	system "rm -rf $run_outDir" if ($overwrite eq 'yes');

	chop $run_outDir if ($run_outDir =~ m/\/$/); #---remove the last slash
	system "mkdir -p -m 755 $run_outDir/";
	
	return($run_outDir, $overwrite);

}
sub run_task {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 1_run|95
#	secondaryAppearInSection: >none
#	input: $path_hsh_ref, $result_script_dir, $task_info_hsh_ref
#	output: none
#	toCall: &run_task($task_info_hsh_ref, $path_hsh_ref, $result_script_dir);
#	calledInLine: 102
#....................................................................................................................................................#
	
	my ($task_info_hsh_ref, $path_hsh_ref, $result_script_dir) = @_;
	
	my $task_log_info_hsh_ref = {};
	
	foreach my $task_num (sort {$a <=> $b} keys %{$task_info_hsh_ref}) {
		my $task_name = $task_info_hsh_ref->{$task_num}{'task_name'};
		my $script_name = $task_info_hsh_ref->{$task_num}{'script_name'};
		my $task_log_path = $task_info_hsh_ref->{$task_num}{'task_log_path'};
		my $script_path = $path_hsh_ref->{'script_dir'}.'/'.$script_name;
		die "script of $task_name does not exist at $script_path\n" if not -s $script_path;
		my @cmd_param_ary = ($script_path);
		foreach my $indiv_param_ary_ref (@{$task_info_hsh_ref->{$task_num}{'param'}}) {
			my ($param_name, $param_val) = @{$indiv_param_ary_ref};
			if (defined $param_val) {#---[2020/10/07 20:32] specifically for skipping training_signal_path if not input
				push @cmd_param_ary, "--$param_name=$param_val";
			}
		}
		my $cmd = join " ", @cmd_param_ary;
		system "$cmd";
		
		open (TASKLOG, "<", $task_log_path);
		while (<TASKLOG>) {
			chomp;
			my ($workflow_task_num, $workflow_task_name, $workflow_script_name, $status, $time) = split /\t/;
			$task_log_info_hsh_ref->{$script_name}{$workflow_task_num} = [$workflow_task_name, $workflow_script_name, $status, $time];
		}
		close TASKLOG;
	}
	
	print "#=======================#\n";
	print "Results of Demo Test Run.\n";
	print "#=======================#\n";
	
	foreach my $script_name (sort keys %{$task_log_info_hsh_ref}) {
		foreach my $workflow_task_num (sort {$a <=> $b} keys %{$task_log_info_hsh_ref->{$script_name}}) {
			my ($workflow_task_name, $workflow_script_name, $status, $time) = @{$task_log_info_hsh_ref->{$script_name}{$workflow_task_num}};
			if ($status ne 'started') {
				print join "", (join "\t", ($script_name, $workflow_script_name, $status)), "\n";
			}
		}
	}
	
}

exit;


















































